<!DOCTYPE html>
<html lang="de" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Covid Radar</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="papaparse.min.js" charset="utf-8"></script>
  <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <!-- <script src="https://d3js.org/d3-dsv.v1.min.js"></script> -->
  <script src="https://unpkg.com/topojson-client@2"></script>
  <script src="versor.js"></script>
  <script src="helpers.js" charset="utf-8"></script>
  <script src="hacks.js" charset="utf-8"></script>
  <meta name="theme-color" content="#001">
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
</head>
<body style="background-color: #333;">
  <div class="container-fluid mt-0 p-1 border border-secondary rounded" id="mainContainer" style="background-color: #222">

    <!-- BONUS OPTIONS  only displayed if ?bonus=1-->
    <div class="card bg-dark" id="bonusContent" style="display: none">
      <div class="card-body p-0">
        <div class="row">
          <button type="button" class="btn btn-secondary btn-sm" onclick="countryColorMethod='growthRate'; render(countries110)">GrowthRatePerCapita</button>
          &nbsp;
          <button type="button" class="btn btn-secondary btn-sm" onclick="countryColorMethod='casesPerCapita'; render(countries110)">CasesPerCapita</button>
          <a href="tests/test.html">tests</a>
        </div>
        <div class="row">

          <select class="form-control-sm bg-secondary" id="selectProjection" onchange="updateProjection(this.value)"></select>
        </div>

      </div>

    </div>



    <!-- NAVBAR -->

    <!-- <div class="card mb-1">
      <div class="card-body p-0">
        <nav class="navbar navbar-expand-md navbar-dark bg-dark py-1">
          <a class="navbar-brand" href="#">corona-radar.info</a>
          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-item nav-link active" href="#">Welt<span class="sr-only">(current)</span></a>
              <a class="nav-item nav-link" href="#">Exponentiell</a>
              <a class="nav-item nav-link" href="#">Über</a>
            </div>
          </div>
        </nav>
      </div>
    </div> -->



    <!-- MAP CONTAINER -->
    <div class="row">
      <div class="col">
        <div id="mapdiv">

            <!-- SETTINGS -->
            <div class="row container-fluid p-1" style="position:absolute; bottom:0px;">

              <div class="col-4">
                <div class="btn-group btn-group-toggle" data-toggle="buttons">
                  <label class="btn btn-dark btn-sm border border-secondary active" style="opacity: 0.7;" onclick="setLin('graph');">
                    <input type="radio" name="options" id="option1" autocomplete="off" checked> Lin
                  </label>
                  <label class="btn btn-dark btn-sm border border-secondary" style="opacity: 0.7;" onclick="setLog('graph');">
                    <input type="radio" name="options" id="option2" autocomplete="off" checked> Log
                  </label>
                </div>
              </div>

              <div class="col text-right">
                <button type="button" class="btn btn-dark btn-sm border border-secondary" style="opacity: 0.7;" onclick="updateProjection('geoOrthographic');">Kugel</button>
                <button type="button" class="btn btn-dark btn-sm border border-secondary" style="opacity: 0.7;" onclick="updateProjection('geoNaturalEarth2');">Natural</button>
                <button type="button" class="btn btn-dark btn-sm border border-secondary" style="opacity: 0.7;" onclick="updateProjection('geoPolyhedralButterfly');">Butterfly</button>
              </div>

            </div>


          <!-- CANVAS -->
          <canvas id="mapcanvas">
          </canvas>

          <!-- OVERLAY -->
          <div class="border border-dark rounded p-1 m-1" style="z-index: 3000; position: absolute; top:0px; background-color: rgba(52,58,64,0.7);">
                    <h5 class="text-white mb-0"><img id=js-flag src=""><span id="js-country">Land wählen</span></h5>
                    <span class="text-secondary" id="js-population"></span>
          </div>

        </div>
      </div>
    </div>


    <!-- STATS CONTAINER-->
    <div class="row mb-1">
      <div class="col">
        <div class="card bg-dark quartett">

          <!-- QUARTETT -->
          <div class="card-header py-0">
              <div class="row pt-1">
                <div class="col text-center">
                  <h5 class="m-0"><span class="badge badge-pill badge-primary" id="js-confirmed">-</span></h5>
                  <p class="m-0">gemeldet</p>
                </div>
                <div class="col text-center">
                  <h5 class="m-0 text-white"><span class="badge badge-pill badge-primary" id="js-percapita">-</span></h5>
                  <p class="m-0">der Bevölkerung</p>
                </div>
                <div class="col text-center">
                  <h5 class="m-0"><span class="badge badge-pill badge-secondary" id="js-deaths">-</span></h5>
                  <p class="m-0">gestorben</p>
                </div>
              </div>
          </div>

          <!-- GRAPH -->
          <div class="card-body p-0 m-0">
            <div class="row">
              <div class="col">
                <div class="bubbleplot" data-num="0">
                  <div id="graph">
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- FOOTER -->
    <div class="row">
      <div class="col text-right text-secondary">
        <a class="text-secondary" href="dsgvo.html">Datenschutzerklärung</a>&nbsp;&#10072;&nbsp;<a class="text-secondary" href="impressum.html">Impressum</a>
      </div>
    </div>

  </div>

  <script>
  //----------------------- GLOBALS --------------------------------------------
  var knownProjections = ['geoAiry', 'geoAitoff', 'geoAlbers', 'geoArmadillo', 'geoAugust', 'geoAzimuthalEqualArea', 'geoAzimuthalEquidistant', 'geoBaker', 'geoBerghaus', 'geoBertin1953', 'geoBoggs', 'geoBonne', 'geoBottomley', 'geoBromley', 'geoChamberlinAfrica', 'geoCollignon', 'geoConicEqualArea', 'geoConicEquidistant', 'geoCraig', 'geoCraster', 'geoCylindricalEqualArea', 'geoCylindricalStereographic', 'geoEckert1', 'geoEckert2', 'geoEckert3', 'geoEckert4', 'geoEckert5', 'geoEckert6', 'geoEisenlohr', 'geoEquirectangular', 'geoFahey', 'geoFoucaut', 'geoFoucautSinusoidal', 'geoGilbert', 'geoGingery', 'geoGinzburg4', 'geoGinzburg5', 'geoGinzburg6', 'geoGinzburg8', 'geoGinzburg9', 'geoGnomonic', 'geoGringorten', 'geoGuyou', 'geoHammer', 'geoHammerRetroazimuthal', 'geoHealpix', 'geoHill', 'geoHomolosine', 'geoHufnagel', 'geoHyperelliptical', 'geoKavrayskiy7', 'geoLagrange', 'geoLarrivee', 'geoLaskowski', 'geoLoximuthal', 'geoMercator', 'geoMiller', 'geoModifiedStereographicAlaska', 'geoModifiedStereographicGs48', 'geoModifiedStereographicGs50', 'geoModifiedStereographicMiller', 'geoModifiedStereographicLee', 'geoMollweide', 'geoMtFlatPolarParabolic', 'geoMtFlatPolarQuartic', 'geoMtFlatPolarSinusoidal', 'geoNaturalEarth1', 'geoNaturalEarth2', 'geoNellHammer', 'geoNicolosi', 'geoOrthographic', 'geoPatterson', 'geoPolyconic', 'geoRectangularPolyconic', 'geoRobinson', 'geoSatellite', 'geoSinusoidal', 'geoSinuMollweide', 'geoStereographic', 'geoTimes', 'geoTransverseMercator', 'geoTwoPointAzimuthalUsa', 'geoTwoPointEquidistantUsa', 'geoVanDerGrinten', 'geoVanDerGrinten2', 'geoVanDerGrinten3', 'geoVanDerGrinten4', 'geoWagner', 'geoWagner4', 'geoWagner6', 'geoWagner7', 'geoWiechel', 'geoWinkel3', 'geoInterruptedHomolosine', 'geoInterruptedSinusoidal', 'geoInterruptedBoggs', 'geoInterruptedSinuMollweide', 'geoInterruptedMollweide', 'geoInterruptedMollweideHemispheres', 'geoInterruptedQuarticAuthalic', 'geoPolyhedralButterfly', 'geoPolyhedralCollignon', 'geoPolyhedralWaterman', 'geoGringortenQuincuncial', 'geoPeirceQuincuncial']

  var countries,
      countries110,
      countries50,
      ecdc,
      countryLookupTable,
      sphere = {type: "Sphere"},
      circles = {"type":"FeatureCollection", "features":[]},
      graticule = d3.geoGraticule10();

  var canvas = d3.select("canvas"),
      width = canvas.property("width"),
      height = canvas.property("height"),
      context = canvas.node().getContext("2d");

  context['countryName'] = "";

  // if (window.devicePixelRatio) {
  //   var devicePixelRatio = window.devicePixelRatio;
  //   var canvasWidth = canvas.getAttribute("width");
  //   var canvasHeight = canvas.getAttribute("height");
  //
  //   canvas.style.width = canvasWidth+"px";
  //   canvas.style.height = canvasHeight+"px";
  //   canvas.setAttribute("width", canvasWidth*devicePixelRatio);
  //   canvas.setAttribute("height", canvasHeight*devicePixelRatio);
  //   ctx.transform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  // }

  var projection = d3.geoOrthographic()
      .scale((height - 10) / 2)
      .translate([width / 2, height / 2])
      .precision(.1);

  var v0, // Mouse position in Cartesian coordinates at start of drag gesture.
      r0, // Projection rotation as Euler angles at start.
      q0; // Projection rotation as versor at start.


  var path = d3.geoPath()
      .projection(projection)
      .context(context);

  var makeCircle = d3.geoCircle().precision(360/5);

  var zoomLevel = 1,
      zoomDefault = 1;

  var interpolationMethod = 'interpolateRdYlGn';

  var globalScale;

  var countryColorMethod = 'casesPerCapita';

  var urlParameters = parseUrlParameters();

  graphAxisType = 'linear';

  // -------------------------------- FUNCTIONS ----------------------------------
  function parseUrlParameters()
  {
    var params={};
    window.location.search
      .replace(/[?&]+([^=&]+)=([^&]*)/gi, function(str,key,value) {
      params[key] = value;
    });
    return params;
  }


function lookupCountry(name, name_from, name_to)
{
  var result;
  var found = false;
  countryLookupTable.forEach((item, i)=>{
    if (item[name_from] == name){
      found = true;
      result = item[name_to];
    }
  });

  if (!found) {
    console.error("Country '"  + name + "' not found in list '" + name_from + "'");
  }
  else {
    return result;
  }
}


function setElementById(id, text)
{
    document.querySelector("#"+id).innerHTML = text;
}


function formatNumber(num) {
  return num.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.')
}


function onClick()
{
    var c = getCountry(this);

    if (c) {
      console.log(c);
      context['countryName'] = c.properties.admin;
      render(countries110);
      document.getElementById("js-flag").src = "https://www.countryflags.io/" + c.properties.wb_a2 + "/shiny/48.png";

      setElementById("js-country", " " + lookupCountry(c.properties.wb_a2, 'wb_a2', 'deutsch'));
      setElementById("js-population", formatNumber(c.properties.pop_est) + " Ew.");
      setElementById("js-confirmed", formatNumber(c.properties.jhiConfirmed.slice(-1)[0]));  //slice is shallow, only use for 1D-arrays
      setElementById("js-deaths", formatNumber(c.properties.jhiDeaths.slice(-1)[0]));
      setElementById("js-percapita", "= " + formatNumber(Math.round(10000 * c.properties.jhiConfirmed.slice(-1)[0] / c.properties.pop_est)/10) + "&permil;");
      // setElementById("js-recovered", formatNumber(c.properties.jhiRecovered.slice(-1)[0]));
      makePlot2(c);

    }
  }


  function polygonContains(polygon, point) {
    var n = polygon.length
    var p = polygon[n - 1]
    var x = point[0], y = point[1]
    var x0 = p[0], y0 = p[1]
    var x1, y1
    var inside = false
    for (var i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1]
      if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside
      x0 = x1, y0 = y1
    }
    return inside
  }


  function getCountry(event) {
    var pos = projection.invert(d3.mouse(event))
    return countries.features.find(function(f) {
      return f.geometry.coordinates.find(function(c1) {
        return polygonContains(c1, pos) || c1.find(function(c2) {
          return polygonContains(c2, pos)
        })
      })
    })
  }


  function roundRect(x, y, w, height, radius, fill, stroke) {
    if (typeof radius === 'number') {
      radius = {tl: radius, tr: radius, br: radius, bl: radius};
    } else {
      var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
      for (var side in defaultRadius) {
        radius[side] = radius[side] || defaultRadius[side];
      }
    }
    context.beginPath();
    // context.moveTo(x + radius.tl, y);
    context.lineTo(x + w - radius.tr, y);
    context.quadraticCurveTo(x + w, y, x + w, y + radius.tr);
    context.lineTo(x + w, y + height - radius.br);
    context.quadraticCurveTo(x + w, y + height, x + w - radius.br, y + height);
    context.lineTo(x + radius.bl, y + height);
    context.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    context.lineTo(x, y + radius.tl);
    context.quadraticCurveTo(x, y, x + radius.tl, y);
    context.closePath();

    if (fill) {
      context.fill();
    }
    if (stroke) {
      context.stroke();
    }
  }


  function drawTextBG(ctx, txt, font, x, y) {
    ctx.save();  /// lets save current state as we make a lot of changes
    ctx.font = font; /// set font
    ctx.textBaseline = 'top'; /// draw text from top - makes life easier at the moment
    ctx.fillStyle = '#32383e'; /// color for background
    roundRect(x, y, ctx.measureText(txt).width, parseInt(font, 10), radius=4, fill='#32383e', stroke=true)
    // ctx.fillRect(x, y, ctx.measureText(txt).width, parseInt(font, 10)); /// draw background rect assuming height of font
    ctx.fillStyle = '#000'; /// text color
    ctx.fillText(txt, x, y); /// draw text on top
    ctx.restore(); /// restore original state
  }


  function makeCountryColor(item, method) {
    if (method=='growthRate') {
      // siehe: https://www.sciencemediacenter.de/alle-angebote/rapid-reaction/details/news/vorbereitungen-in-krankenhaeusern-auf-covid-19/
      // console.log(item.properties.admin, item.properties.pop_est / 82329758, item.properties.jhiLatestGrowth[0] / 20000)
      return d3[interpolationMethod](1 - (item.properties.jhiLatestGrowth[0] / (20000 * (item.properties.pop_est / 82329758))));
    }
    else {
      return d3[interpolationMethod](1-(Math.log10(100000 * item.properties.jhiConfirmed.slice(-1)[0] / item.properties.pop_est) / 5));
    }
  }


  function render(rendercountries) {
    context.clearRect(0, 0, width, height);
    context.beginPath(), path(sphere), context.fillStyle = "#224", context.fill();
    context.beginPath(), path(graticule), context.strokeStyle = '#234', context.stroke();
    rendercountries.features.forEach((item, i) => {
      var color = makeCountryColor(item, countryColorMethod);
      context.beginPath(), path(item), context.fillStyle = color, context.fill(),
                                       context.strokeStyle = '#888', context.stroke();
    });
    // if (context.countryName) drawTextBG(context, context.countryName, '30px Arial', 10, 50);
    context.beginPath(), path(sphere), context.stroke();

    // context.font = "30px Arial", context.fillText(context.countryName, 10, 50);
    // context.beginPath(), path(circles), context.stroke(), context.fillStyle = '#f00', context.fill();
  }


  function updateProjection(projectionName) {
    d3.zoom().transform(canvas, d3.zoomIdentity);

    projection = d3[projectionName]()
        .scale((height) / 2)
        .translate([width / 2, height / 2])
        .precision(.1);

    var tmp = projection.scale();

    path = d3.geoPath()
        .projection(projection)
        .context(context);

    var bounds = path.bounds(sphere),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scalefactor = Math.max(dx / width, dy / height),
      translate = [width / 2 - scalefactor * x, height / 2 - scalefactor * y];

    var transform = d3.zoomIdentity
    .translate(translate[0], translate[1])
    .scale(1/scalefactor);

    // canvas.transition()
    // .duration(750)
    // .call(d3.zoom().transform, transform);

    // canvas.call(d3.zoom().transform, transform);
    d3.zoom().transform(canvas, transform);
    projection.scale( (1/scalefactor) * ((height - 10 )/2));
    // projection.scale(zoomLevel * (height - 10)/2);
    // canvas.call(d3.zoom().scaleTo, 1 / projection.scale());
    // canvas.transition().duration(750).call(d3.zoom().transform, d3.zoomIdentity);
    // projection.scale(height/scalefactor);
    render(countries110);

    // d3.zoom().scaleBy(canvas, 1/scalefactor);
    // render(countries50);

    // render(countries50);


    // resize(true);
  }


  function zoomstarted() {
      // countries = countries110;
      v0 = versor.cartesian(projection.invert(d3.mouse(this)));
      r0 = projection.rotate();
      q0 = versor(r0);
  }

  function zoomed() {
      zoomLevel =  d3.event.transform.k;
      projection.scale(d3.event.transform.k * (height - 10) / 2);

      var v1 = versor.cartesian(projection.rotate(r0).invert(d3.mouse(this))),
          q1 = versor.multiply(q0, versor.delta(v0, v1)),
          r1 = versor.rotation(q1);
          r1[2] = 0;     //north up
      projection.rotate(r1);
      render(countries110);
  }

  function zoomended() {
    // countries = countries50;
    render(countries110);
  }


  function resize(doZoom = true) {
      width = document.getElementById('mapdiv').clientWidth;
      // height = document.querySelector('.quartett').clientHeight;
      height = Math.min(width/1.5,globalScale * 500);
      d3.select('#mapcanvas')
        .attr('width', width)
        .attr('height', height);

      projection.translate([width / 2, height / 2]);
      if (doZoom == true){
        projection.scale(zoomLevel * (height - 10) / 2);

      }

      render(countries110);
  }


  function ppConvertNumbers(val) {
    if (!isNaN(Number(val))) {
      return Number(val);
    }
    else {
      // console.log(val);
      return val;
    }
  }


  function calculateGrowth()
  {

  }


  function integrateJhiData(attributes, targetMap)
  {
    var propNames = ['jhiConfirmed', 'jhiDeaths', 'jhiRecovered'];

    attributes.forEach((element, i) =>{
      var jhiNice = makeNiceCsv(Papa.parse(element, {transform: ppConvertNumbers}).data);
      propertyName = propNames.shift();
      targetMap.features.forEach((item, j) => {
        var jhiName = lookupCountry(item.properties.wb_a2, 'wb_a2', 'jhi');
        var idx = unpack(jhiNice, 0).indexOf(jhiName);
        if (idx == -1){
          item.properties[propertyName] = [0];
          if (i == 0) item.properties['jhiDates'] = convertDateListForPlotly([jhiNice[0][jhiNice[0].length - 1]]);
        }
        else {
          item.properties[propertyName] = jhiNice[idx].slice(1, jhiNice[idx].length);
          if (i == 0) item.properties['jhiDates'] = convertDateListForPlotly(jhiNice[0].slice(1, jhiNice[0].length));
        }
      });
    });

    // calculateGrowth
    var jhiNice = makeNiceCsv(Papa.parse(attributes[0], {transform: ppConvertNumbers}).data);
    targetMap.features.forEach((item, i) => {
      var jhiName = lookupCountry(item.properties.wb_a2, 'wb_a2', 'jhi');
      var idx = unpack(jhiNice, 0).indexOf(jhiName);
      if (idx == -1){
        item.properties['jhiLatestGrowth'] = [0];
      }
      else {
        item.properties['jhiLatestGrowth'] = [(jhiNice[idx][jhiNice[idx].length - 1] - jhiNice[idx][jhiNice[idx].length - 4]) / 3];
      }
    });

  }


  function integrateEcdcData(ecdc) {
    ecdc.forEach((item, i) => {

    });
  }


  // -------------------------------- INIT ---------------------------------------
  canvas.call(d3.zoom().on("start", zoomstarted)
                       .on('zoom', zoomed)
                       .on("end", zoomended));
  canvas.on('click', onClick);


  var promises = [];

  promises.push(d3.json("data/custom-110m.geo.json"));
  // promises.push(d3.json("data/custom-50m.geo.json"));
  promises.push(d3.tsv("data/countries-consolidated.csv"));
  promises.push(d3.text("data/time_series_covid19_confirmed_global.csv"));
  promises.push(d3.text("data/time_series_covid19_deaths_global.csv"));
  promises.push(d3.text("data/time_series_19-covid-Recovered.csv"));
  promises.push(d3.csv("data/COVID-19-geographic-disbtribution-worldwide.csv"));
      // .defer(jQuery.get, 'http://localhost/foo.txt')
      // .await(ready);

      Promise.all(promises).then(function(values) {
        ready(values);
      });


  function ready([ne110, lookupData, jhConfirmedString, jhDeathsString, jhRecoveredString, ecdcInput])
  {
    // set global font-size, bootstrap derives its font-sizes from html font-size
    globalScale = window.devicePixelRatio;
    // TODO PRÜFEN
    if (globalScale > 1) {
      $('html')[0].style['font-size'] = globalScale * 12 + 'px';
    }
    else {
      $('html')[0].style['font-size'] = '16px';
    }
    // set maxwidth for main-container
    $('#mainContainer')[0].style['max-width'] = globalScale * 1200 + 'px';

    // show Bonus Content if get variable bonus=1
    if (urlParameters['bonus']){
      $('#bonusContent')[0].style['display'] = 'flex';
    }


    ecdc = ecdcInput;
    countries110 = ne110;
    countries = countries110;
    countryLookupTable = lookupData;

    // countries50 = ne110;
    // integrateJhiData([jhConfirmedString, jhDeathsString, jhRecoveredString], countries50);  //Obacht, Reihenfolge der Strings nicht ändern!
    integrateJhiData([jhConfirmedString, jhDeathsString, jhRecoveredString], countries110); //Obacht, Reihenfolge der Strings nicht ändern!

    assignOptions(knownProjections, $('#selectProjection')[0]);

    // make Circles at each datapoint of jhi
    // var jhi = Papa.parse(jhConfirmedString).data;
    // jhi.forEach((item, i) => {
    //   circles.features.push({ "type": "Feature",
    //     "geometry": makeCircle.center([item[3],item[2]]).radius(1)(),
    //     "properties": {"prop0": "value0"}
    //   });
    // });
    zoomDefault = projection.scale();
    resize(true);

    window.onresize = resize;
  }


  </script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
